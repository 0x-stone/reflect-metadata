{"name":"ReflectDecorators","tagline":"Prototype for an ES7 Reflection API for Decorator Metadata","body":"Proposal to add Decorators to ES7, along with a prototype for an ES7 Reflection API for Decorator Metadata\r\n\r\n# <a name=\"1\"/>1 Motivating examples\r\n\r\n## <a name=\"1.1\"/>1.1 Conditional implementation \r\n\r\nConditional code generation:\r\n\r\n```TypeScript\r\nclass Debug {  \r\n    @conditional(\"debug\")  \r\n    static assert(condition: boolean, message?: string): void;  \r\n}  \r\n  \r\nDebug.assert(false); // if window.debug is not defined Debug.assert is replaced by an empty function\r\n```\r\n\r\n## <a name=\"1.2\"/>1.2 Observable and computed properties\r\n\r\nConsider the Ember.js alias-like definition:\r\n\r\n```TypeScript\r\nclass Person {  \r\n    constructor(public firstName: string, public lastName: string) { }\r\n  \r\n    @computed('firstName', 'lastName', (f, l) => l + ', ' + f)  \r\n    fullName: string;\r\n}  \r\n  \r\nvar david = new Person('David', 'Tang');  \r\ndavid.fullName; /// Tang, David\r\n```\r\n\r\n## <a name=\"1.3\"/>1.3 Dynamic Instantiation (composition)\r\n\r\nConsider Angular 2.0 DI implementation example:\r\n\r\n```TypeScript\r\nclass Engine {  \r\n}  \r\n  \r\nclass Car {  \r\n    constructor(@Inject(Engine) engine: Engine) {}  \r\n}  \r\n  \r\nvar inj = new Injector([Car, Engine]);  \r\n  \r\n// AtScript compilation step adds a property “annotations” on Car of value [ new Inject(Engine) ].  \r\n// At runtime, a call to inj.get would cause Angular to look for annotations, and try to satisfy dependencies.  \r\n// in this case first by creating a new instance of Engine if it does not exist, and use it as a parameter to Car’s constructor  \r\nvar car = inj.get(Car);\r\n```\r\n\r\n## <a name=\"1.4\"/>1.4 Attaching Meta data to functions/objects\r\n\r\nMetadata that can be queried at runtime, for example:\r\n\r\n```TypeScript\r\nclass Fixture {  \r\n    @isTestable(true)  \r\n    getValue(a: number): string {  \r\n        return a.toString();  \r\n    }  \r\n}  \r\n  \r\n// Desired JS  \r\nclass Fixture {  \r\n    getValue(a) {  \r\n        return a.toString();  \r\n    }  \r\n}  \r\nFixture.prototype.getValue.meta.isTestable = true;  \r\n  \r\n// later on query the meta data  \r\nfunction isTestableFunction(func) {  \r\n    return !!(func && func.meta && func.meta.isTestable);  \r\n}\r\n```\r\n\r\n## <a name=\"1.5\"/>1.5 Design-time extensibility\r\n\r\nAn extensible way to declare properties on or associate special behavior to declarations; design time tools can leverage these associations to produce errors or produce documentation. For example:\r\n\r\nDeprecated, to support warning on use of specific API’s:\r\n\r\n```TypeScript\r\ninterface JQuery {  \r\n    /**  \r\n     * A selector representing selector passed to jQuery(), if any, when creating the original set.  \r\n     * version deprecated: 1.7, removed: 1.9  \r\n     */  \r\n    @deprecated(\"Property is only maintained to the extent needed for supporting .live() in the jQuery Migrate plugin. It may be removed without notice in a future version.\", false)  \r\n    selector: string;  \r\n}\r\n```\r\n\r\nSuppress linter warning:\r\n\r\n```TypeScript\r\n@suppressWarning(\"disallow-leading-underscore\")   \r\nfunction __init() {  \r\n}\r\n```\r\n\r\n# <a name=\"2\"/>2 Proposal\r\n\r\n## <a name=\"2.1\"/>2.1 Terms\r\n\r\n### <a name=\"2.1.1\"/>2.1.1 Decorator\r\n\r\nA *decorator* is an expression that is evaluated after a class has been defined, that can be used to annotate or modify the class in some fashion. This expression must evaluate to a **function**, which is executed by the runtime to apply the decoration.\r\n\r\n```TypeScript\r\n@decoratorExpression\r\nclass C {\r\n}\r\n```\r\n\r\n### <a name=\"2.1.2\"/>2.1.2 Class Decorator Function\r\n\r\nA *class decorator function* is a function that accepts a constructor function as its argument, and returns either `undefined`, the provided constructor function, or a new constructor function. Returning `undefined` is equivalent to returning the provided constructor function.\r\n\r\n```TypeScript\r\n// A class decorator\r\nfunction dec(target) {  \r\n   // modify, annotate, or replace target...\r\n}\r\n```\r\n\r\n### <a name=\"2.1.3\"/>2.1.3 Property/Method Decorator Function\r\n\r\nA *property decorator function* is a function that accepts three arguments: The object that owns the property, the key for the property (a `string` or a `symbol`), and optionally the property descriptor of the property. The function must return either `undefined`, the provided property descriptor, or a new property descriptor. Returning `undefined` is equivalent to returning the provided property descriptor.\r\n\r\n```TypeScript\r\n// A property (or method/accessor) decorator\r\nfunction dec(target, key, descriptor) {\r\n\t// annotate the target and key; or modify or replace the descriptor...\r\n}\r\n```\r\n\r\n### <a name=\"2.1.4\"/>2.1.4 Parameter Decorator Function\r\n\r\nA *parameter decorator function* is a function that accepts two arguments: The function that contains the decorated parameter, and the ordinal index of the parameter. The return value of this decorator is ignored.\r\n\r\n```TypeScript\r\n// A parameter decorator\r\nfunction dec(target, paramIndex) {\r\n\t// annotate the target and index\r\n}\r\n```\r\n\r\n### <a name=\"2.1.5\"/>2.1.5 Decorator Factory\r\n\r\nA *decorator factory* is a function that can accept any number of arguments, and must return one of the above types of *decorator function*.\r\n\r\n```TypeScript\r\n// a class decorator factory\r\nfunction dec(x, y) {\r\n\t// the class decorator function\r\n\treturn function (target) {\r\n\t\t// modify, annotate, or replace target...\r\n\t}\r\n}\r\n```\r\n\r\n## <a name=\"2.2\"/>2.2 Decorator Targets\r\n\r\nA *decorator* **can** be legally applied to any of the following:\r\n\r\n* A class declaration\r\n* A class property declaration (static or prototype)\r\n* A class method declaration (static or prototype)\r\n* A class get or set accessor declaration (static or prototype)\r\n* A parameter of a class constructor\r\n* A parameter of a class method (static or prototype)\r\n* A parameter of a class get or set accessor (static or prototype)\r\n\r\nPlease note that a *decorator* currently **cannot** be legally applied to any of the following:\r\n\r\n* A class constructor - This is to reduce ambiguity between where you can apply a decorator (on the class or on its constructor) and which of the above *decorator function* forms is called.\r\n* A function declaration - Decorators on a function declaration would introduce a TDZ (Temporal Dead Zone), which would make the function unreachable until its declaration is executed. This could cause confusion as an undecorated function declaration is hoisted and can be used in a statement preceeding the declaration.\r\n* A function expression - This is to reduce confusion and maintain parity with disallowing decorators on a function declaration.\r\n* An arrow function - This is to reduce confusion and maintain parity with disallowing decorators on a function expression.\r\n\r\nThis list may change in the future. \r\n\r\n## <a name=\"2.3\"/>2.3 Decorator Evaluation and Application Order\r\n\r\nDecorators are *evaluated* in the order they appear preceeding their target declaration, to preserve side-effects due to evaluation order. Decorators are *applied* to their target declaration in reverse order, starting with the decorator closest to the declaration. This behavior is specified to preserve the expected behavior of decorators without a declarative syntax. \r\n\r\n```TypeScript\r\n@F\r\n@G\r\nclass C {\t\r\n}\r\n```\r\n\r\nFor example, the above listing could be approximately written without decorators in the following fashion:\r\n\r\n```TypeScript\r\nC = F(G(C))\r\n```\r\n\r\nIn the above example, the expression `F` is *evaluated* first, followed by the expression `G`. `G` is then called with the constructor function as its argument, followed by calling `F` with the result.  The actual process of applying decorators is more complex than the above example however, though you may still imperatively apply decorators with a [reflection API](#4).\r\n\r\nIf a class declaration has decorators on both the class and any of its members or parameters, the decorators are applied using the following pseudocode:\r\n\r\n```\r\nfor each member M of class C\r\n\tif M is an accessor then\r\n\t\tlet accessor = first accessor (get or set, in declaration order) of M\r\n\t\tlet memberDecorators = decorators of accessor\r\n\t\tfor each parameter of accessor\r\n\t\t\tlet paramDecorators = decorators of parameter\t\t\t\r\n\t\t\tlet paramIndex = ordinal index of parameter\r\n\t\t\tReflect.decorate(paramDecorators, accessor, paramIndex)\r\n\t\tnext parameter\r\n\r\n\t\tlet accessor = second accessor (get or set, in declaration order) of M\r\n\t\tif accessor then\r\n\t\t\tlet memberDecorators = memberDecorators + decorators of accessor\r\n\t\t\tfor each parameter of accessor\r\n\t\t\t\tlet paramDecorators = decorators of parameter\t\t\t\r\n\t\t\t\tlet paramIndex = ordinal index of parameter\r\n\t\t\t\tReflect.decorate(paramDecorators, accessor, paramIndex)\r\n\t\t\tnext parameter\r\n\t\tend if\r\n\telse if M is a method\r\n\t\tlet memberDecorators = decorators of M\r\n\t\tfor each parameter of M\r\n\t\t\tlet paramDecorators = decorators of parameter\t\t\t\r\n\t\t\tlet paramIndex = ordinal index of parameter\r\n\t\t\tReflect.decorate(paramDecorators, M, paramIndex)\r\n\t\tnext parameter\r\n\telse\r\n\t\tlet memberDecorators = decorators of M\r\n\tend if\r\n\r\n\tlet name = name of M\r\n\tlet target = C.prototype if M is on the prototype; otherwise, C if M is static\t\r\n\tReflect.decorate(memberDecorators, C, name)\r\nnext member\r\n\r\nfor each parameter of C\r\n\tlet paramDecorators = decorators of parameter\r\n\tlet paramIndex = ordinal index of parameter\r\n\tReflect.decorate(paramDecorators, C, paramIndex)\r\nnext parameter\r\n\r\nlet classDecorators = decorators of C\r\nlet C = Reflect.decorate(classDecorators, C)\r\n```\r\n\r\n# <a name=\"3\"/>3 Transformation details\r\n\r\nThe following are examples of how decorators can be desugared to ES6 (through a transpiler such as TypeScript). These examples levarage an imperative reflection API.\r\n\r\n## <a name=\"3.1\"/>3.1 Class Declaration\r\n\r\n### <a name=\"3.1.1\"/>3.1.1 Syntax\r\n\r\n```TypeScript\r\n@F(\"color\")  \r\n@G  \r\nclass C {\r\n}\r\n```\r\n\r\n### <a name=\"3.1.2\"/>3.1.2 ES6 Desugaring\r\n\r\n```TypeScript\r\nvar C = (function () {  \r\n    class C {  \r\n    }\r\n\r\n    C = Reflect.decorate([F(\"color\"), G], C);\r\n    return C;\r\n})();\r\n```\r\n\r\n## <a name=\"3.2\"/>3.2 Class Method Declaration\r\n\r\n### <a name=\"3.2.1\"/>3.2.1 Syntax\r\n\r\n```TypeScript\r\nclass C {  \r\n    @F(\"color\")  \r\n    @G  \r\n    bar() { }  \r\n}\r\n```\r\n\r\n### <a name=\"3.2.2\"/>3.2.2 ES6 Desugaring\r\n\r\n```TypeScript\r\nvar C = (function () {  \r\n    class C {  \r\n        bar() { }  \r\n    }\r\n\r\n    Reflect.decorate([F(\"color\"), G], C.prototype, \"bar\");\r\n    return C;  \r\n})();\r\n```\r\n\r\n## <a name=\"3.3\"/>3.3 Class Accessor Declaration\r\n\r\n### <a name=\"3.3.1\"/>3.3.1 Syntax\r\n\r\n```TypeScript\r\nclass C {  \r\n    @F(\"color\")  \r\n    get bar() { }  \r\n\r\n    @G  \r\n    set bar(value) { }  \r\n}\r\n```\r\n\r\n### <a name=\"3.3.2\"/>3.3.2 ES6 Desugaring\r\n\r\n```TypeScript\r\nvar C = (function () {  \r\n    class C {  \r\n        get bar() { }  \r\n        set bar(value) { }  \r\n    }  \r\n\r\n    Reflect.decorate([F(\"color\"), G], C.prototype, \"bar\");\r\n    return C;  \r\n})();\r\n```\r\n\r\n## <a name=\"3.4\"/>3.4 Class Property Declaration (TypeScript)\r\n\r\n### <a name=\"3.4.1\"/>3.4.1 Syntax\r\n\r\n```TypeScript\r\nclass C {  \r\n    @F(\"color\") \r\n    @g\r\n    property;\r\n}\r\n```\r\n\r\n### <a name=\"3.4.2\"/>3.4.2 ES6 Desugaring\r\n\r\n```TypeScript\r\nvar C = (function () {  \r\n    class C {  \r\n    }  \r\n\r\n    Reflect.decorate([F(\"color\"), G], C.prototype, \"property\");\r\n    return C;  \r\n})();\r\n```\r\n\r\n## <a name=\"3.5\"/>3.5 Constructor Parameter Declaration\r\n\r\n### <a name=\"3.5.1\"/>3.5.1 Syntax\r\n\r\n```TypeScript\r\nclass C {  \r\n    constructor(@F(\"color\") @G x) {\r\n    }\r\n}\r\n```\r\n\r\n### <a name=\"3.5.2\"/>3.5.2 ES6 Desugaring\r\n\r\n```TypeScript\r\nvar C = (function () {  \r\n    class C {  \r\n        constructor(x) {  \r\n        }  \r\n    }  \r\n  \r\n  \tReflect.decorate([F(\"color\"), G], C, /*paramIndex*/ 0);\r\n    return C;  \r\n})();\r\n```\r\n\r\n## <a name=\"3.6\"/>3.6 Method Parameter Declaration\r\n\r\n### <a name=\"3.6.1\"/>3.6.1 Syntax\r\n\r\n```TypeScript\r\nclass C {  \r\n    method(@F(\"color\") @G x) {\r\n    }\r\n}\r\n```\r\n\r\n### <a name=\"3.6.2\"/>3.6.2 ES6 Desugaring\r\n\r\n```TypeScript\r\nvar C = (function () {  \r\n    class C {  \r\n        method(x) {  \r\n        }  \r\n    }  \r\n  \r\n  \tReflect.decorate([F(\"color\"), G], C.prototype.method, /*paramIndex*/ 0);\r\n    return C;  \r\n})();\r\n```\r\n\r\n## <a name=\"3.7\"/>3.7 Set Accessor Parameter Declaration\r\n\r\n### <a name=\"3.7.1\"/>3.7.1 Syntax\r\n\r\n```TypeScript\r\nclass C {  \r\n    set accessor(@F(\"color\") @G x) {\r\n    }\r\n}\r\n```\r\n\r\n### <a name=\"3.5.2\"/>3.5.2 ES6 Desugaring\r\n\r\n```TypeScript\r\nvar C = (function () {  \r\n    class C {  \r\n        set accessor(x) {  \r\n        }  \r\n    }  \r\n  \r\n  \tReflect.decorate([F(\"color\"), G], Object.getOwnPropertyDescriptor(C.prototype, \"accessor\").set, /*paramIndex*/ 0);\r\n    return C;  \r\n})();\r\n```\r\n\r\n# <a name=\"4\"> 4 Metadata Reflection API\r\nIn addition to a declarative approach to defining decorators, it is necessary to also include an imperative API capable of applying decorators, as well as defining, reflecting over, and removing decorator metadata from an object, property, or parameter. \r\n\r\nA shim for this API can be found here: https://github.com/rbuckton/ReflectDecorators\r\n\r\n## <a name=\"4.1\"> 4.1 API\r\n```TypeScript\r\ntype ClassDecorator = (target: Function) => Function | void;\r\ntype ParameterDecorator = (target: Function, paramIndex: number) => void;\r\ntype PropertyDecorator = (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) => PropertyDescriptor | void;\r\ntype Decorator = ClassDecorator | ParameterDecorator | PropertyDecorator;\r\n\r\nmodule Reflect {\r\n    \r\n    // decorator application\r\n    export function decorate(decorators: ClassDecorator[], target: Function): Function;\r\n    export function decorate(decorators: ParameterDecorator[], target: Function, paramIndex: number): void;\r\n    export function decorate(decorators: PropertyDecorator[]), target: Object, propertyKey: string | symbol): void;\r\n\r\n    // built-in metadata decorator factory\r\n    export function metadata(metadataKey: any, metadataValue: any): Decorator;\r\n    \r\n    // metadata\r\n    export function defineMetadata(metadataKey: any, metadata: any, target: Object): void;\r\n    export function defineMetadata(metadataKey: any, metadata: any, target: Object, targetParamIndex: number): void;\r\n    export function defineMetadata(metadataKey: any, metadata: any, target: Object, targetPropertyKey: string | symbol): void;\r\n    \r\n    export function hasMetadata(metadataKey: any, target: Object): boolean;\r\n    export function hasMetadata(metadataKey: any, target: Object, targetParamIndex: number): boolean;\r\n    export function hasMetadata(metadataKey: any, target: Object, targetPropertyKey: string | symbol): boolean;\r\n\r\n    export function hasOwnMetadata(metadataKey: any, target: Object): boolean;\r\n    export function hasOwnMetadata(metadataKey: any, target: Object, targetParamIndex: number): boolean;\r\n    export function hasOwnMetadata(metadataKey: any, target: Object, targetPropertyKey: string | symbol): boolean;\r\n\r\n    export function getMetadata(metadataKey: any, target: Object): any;\r\n    export function getMetadata(metadataKey: any, target: Object, targetParamIndex: number): any;\r\n    export function getMetadata(metadataKey: any, target: Object, targetPropertyKey: string | symbol): any;\r\n\r\n    export function getOwnMetadata(metadataKey: any, target: Object): any;\r\n    export function getOwnMetadata(metadataKey: any, target: Object, targetParamIndex: number): any;\r\n    export function getOwnMetadata(metadataKey: any, target: Object, targetPropertyKey: string | symbol): any;\r\n\r\n    export function getMetadataKeys(target: Object): any[];\r\n    export function getMetadataKeys(target: Object, targetParamIndex: number): any[];\r\n    export function getMetadataKeys(target: Object, targetPropertyKey: string | symbol): any[];\r\n\r\n    export function getOwnMetadataKeys(target: Object): any[];\r\n    export function getOwnMetadataKeys(target: Object, targetParamIndex: number): any[];\r\n    export function getOwnMetadataKeys(target: Object, targetPropertyKey: string | symbol): any[];\r\n\r\n    export function deleteMetadata(metadataKey: any, target: Object): boolean;\r\n    export function deleteMetadata(metadataKey: any, target: Object, targetParamIndex: number): boolean;\r\n    export function deleteMetadata(metadataKey: any, target: Object, targetPropertyKey: string | symbol): boolean;\r\n\r\n    export function mergeMetadata(target: Object, source: Object): Object;\r\n}\r\n```\r\n\r\n## <a name=\"4.2\"> 4.2 Examples\r\n\r\n```TypeScript\r\n// An \"annotation\" factory for a class\r\nfunction Component(options) {\r\n  return target => Reflect.defineMetadata(\"component\", options, target);\r\n}\r\n\r\n// A \"decorator\" factory that replaces the function/class with a proxy\r\nfunction Logged(message) {\r\n  return target => new Proxy(target, {\r\n    apply(target, thisArg, argArray) {\r\n      console.log(message);\r\n      return Reflect.apply(target, thisArg, argArray);\r\n    },\r\n    construct(target, thisArg, argArray) {\r\n      console.log(message);\r\n      return Reflect.construct(target, argArray);\r\n    }\r\n  });\r\n}\r\n\r\n// An \"annotation\" factory for a member\r\nfunction MarshalAs(options) {\r\n  return (target, propertyKey) => Reflect.defineMetadata(MarshalAs, options, target, propertyKey);\r\n}\r\n\r\n// A \"decorator\" factory for a member that mutates its descriptor\r\nfunction Enumerable(value) {\r\n  return (target, propertyKey, descriptor) => {\r\n    descriptor.enumerable = value;\r\n    return descriptor;\r\n  };\r\n}\r\n\r\n// An \"annotation\" factory for a parameter\r\nfunction Inject(type) {\r\n  return (target, parameterIndex) => Reflect.defineMetadata(Inject, type, target, parameterIndex);\r\n}\r\n\r\n// NOTE: A \"decorator\" factory for a parameter cannot mutate the parameter.\r\n```\r\n\r\n### <a name=\"4.2.1\"> 4.2.1 Declarative Usage\r\n```TypeScript\r\n@Component({ /*options...*/ })\r\n@Logged(\"Called class\")\r\nclass MyComponent extends ComponentBase {\r\n  constructor(@Inject(ServiceBase) myService) {\r\n    this.myService = myService;\r\n  }\r\n  \r\n  @MarshalAs({ /*options...*/ })\r\n  @Enumerable(true)\r\n  get service() {\r\n    return this.myService;\r\n  }\r\n}\r\n```\r\n\r\n### <a name=\"4.2.2\"> 4.2.2 Imperative Usage\r\n```TypeScript\r\nclass MyComponent extends ComponentBase {\r\n  constructor(myService) {\r\n    this.myService = myService;\r\n  }\r\n  \r\n  get service() {\r\n    return this.myService;\r\n  }\r\n}\r\n\r\nReflect.decorate([MarshalAs({ /*options...*/}), Enumerable(true)], MyComponent.prototype, \"service\");\r\nReflect.decorate([Inject(ServiceBase)], MyComponent, 0);\r\nMyComponent = Reflect.decorate([Component({ /*options...*/ }), Logged(\"called class\")], MyComponent);\r\n```\r\n\r\n### <a name=\"4.2.3\"> 4.2.3 Composition Sample\r\n```TypeScript\r\n// read annotations\r\nclass Composer {\r\n  constructor() {\r\n    this.types = new Map();\r\n    this.components = new Map();\r\n  }\r\n  for(baseType) {\r\n    return { use: (componentType) => this.types.set(baseType, componentType) };\r\n  }\r\n  get(type) {\r\n    if (this.components.has(type)) {\r\n      return this.components.get(type);\r\n    }\r\n    let componentType = type;\r\n    if (this.types.has(type)) {\r\n      componentType = this.types.get(type);\r\n    }\r\n    let args = new Array(componentType.length);\r\n    for (let i = 0; i < args.length; i++) {\r\n      let injectType = Reflect.getMetadata(Inject, componentType, i);\r\n      if (injectType) {\r\n        args[i] = this.get(injectType);\r\n      }\r\n    }\r\n    let component = Reflect.construct(componentType, args);\r\n    this.components.set(type, component);\r\n    return component;\r\n  }\r\n}\r\n\r\n\r\nlet composer = new Composer();\r\ncomposer.for(ServiceBase).use(MyService);\r\ncomposer.for(ComponentBase).use(MyComponent);\r\nlet component = composer.get(ComponentBase);\r\n```\r\n\r\n# <a name=\"A\"/>A Grammar\r\n\r\nNOTE: this section is out of date and will soon be updated.\r\n\r\n## <a name=\"A.1\"/>A.1 Expressions\r\n\r\n&emsp;&emsp;*DecoratorList*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp; *Decorator*<sub> [?Yield]</sub>\r\n\r\n&emsp;&emsp;*Decorator*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;`@`&emsp;*LeftHandSideExpression*<sub> [?Yield]</sub>\r\n\r\n&emsp;&emsp;*PropertyDefinition*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*IdentifierReference*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*CoverInitializedName*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*PropertyName*<sub> [?Yield]</sub>&emsp; `:`&emsp;*AssignmentExpression*<sub> [In, ?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp;*MethodDefinition*<sub> [?Yield]</sub>\r\n\r\n&emsp;&emsp;*CoverMemberExpressionSquareBracketsAndComputedPropertyName*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;`[`&emsp;*Expression*<sub> [In, ?Yield]</sub>&emsp;`]`\r\n\r\nNOTE\tThe production *CoverMemberExpressionSquareBracketsAndComputedPropertyName* is used to cover parsing a *MemberExpression* that is part of a *Decorator* inside of an *ObjectLiteral* or *ClassBody*, to avoid lookahead when parsing a decorator against a *ComputedPropertyName*. \r\n\r\n&emsp;&emsp;*PropertyName*<sub> [Yield, GeneratorParameter]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*LiteralPropertyName*  \r\n&emsp;&emsp;&emsp;[+GeneratorParameter] *CoverMemberExpressionSquareBracketsAndComputedPropertyName*  \r\n&emsp;&emsp;&emsp;[~GeneratorParameter] *CoverMemberExpressionSquareBracketsAndComputedPropertyName*<sub> [?Yield]</sub>\r\n\r\n&emsp;&emsp;*MemberExpression*<sub> [Yield]</sub>&emsp; :  \r\n&emsp;&emsp;&emsp;[Lexical goal *InputElementRegExp*] *PrimaryExpression*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*MemberExpression*<sub> [?Yield]</sub>&emsp;*CoverMemberExpressionSquareBracketsAndComputedPropertyName*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*MemberExpression*<sub> [?Yield]</sub>&emsp;`.`&emsp;*IdentifierName*  \r\n&emsp;&emsp;&emsp;*MemberExpression*<sub> [?Yield]</sub>&emsp;*TemplateLiteral*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*SuperProperty*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*NewSuper*&emsp;*Arguments*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;`new`&emsp;*MemberExpression*<sub> [?Yield]</sub>&emsp;*Arguments*<sub> [?Yield]</sub>\r\n\r\n&emsp;&emsp;*SuperProperty*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;`super`&emsp;*CoverMemberExpressionSquareBracketsAndComputedPropertyName*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;`super`&emsp;`.`&emsp;*IdentifierName*\r\n\r\n&emsp;&emsp;*CallExpression*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*MemberExpression*<sub> [?Yield]</sub>&emsp;*Arguments*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*SuperCall*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*CallExpression*<sub> [?Yield]</sub>&emsp;*Arguments*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*CallExpression*<sub> [?Yield]</sub>&emsp;*CoverMemberExpressionSquareBracketsAndComputedPropertyName*<sub> [In, ?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*CallExpression*<sub> [?Yield]</sub>&emsp;`.`&emsp;*IdentifierName*  \r\n&emsp;&emsp;&emsp;*CallExpression*<sub> [?Yield]</sub>&emsp;*TemplateLiteral*<sub> [?Yield]</sub>\r\n\r\n## <a name=\"A.4\"/>A.4 Functions and Classes\r\n\r\n&emsp;&emsp;*FormalRestParameter*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp;*BindingRestElement*<sub> [?Yield]</sub>\r\n\r\n&emsp;&emsp;*FormalParameter*<sub> [Yield, GeneratorParameter]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp;*BindingElement*<sub> [?Yield, ?GeneratorParameter]</sub>\r\n\r\n&emsp;&emsp;*ClassDeclaration*<sub> [Yield, Default]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp;`class`&emsp;*BindingIdentifier*<sub> [?Yield]</sub>&emsp;*ClassTail*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;[+Default] *DecoratorList*<sub> [?Yield]opt</sub>&emsp;`class`&emsp;*ClassTail*<sub> [?Yield]</sub>\r\n\r\n&emsp;&emsp;*ClassExpression*<sub> [Yield, GeneratorParameter]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp;`class`&emsp;*BindingIdentifier*<sub> [?Yield]opt</sub>&emsp;*ClassTail*<sub> [?Yield, ?GeneratorParameter]</sub>\r\n\r\n&emsp;&emsp;*ClassElement*<sub> [Yield]</sub>&emsp;:  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp;*MethodDefinition*<sub> [?Yield]</sub>  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> [?Yield]opt</sub>&emsp;`static`&emsp;*MethodDefinition*<sub> [?Yield]</sub>\r\n\r\n## <a name=\"A.5\"/>A.5 Scripts and Modules\r\n\r\n&emsp;&emsp;*ExportDeclaration*&emsp;:  \r\n&emsp;&emsp;&emsp;`export`&emsp;`*`&emsp;*FromClause*&emsp;`;`  \r\n&emsp;&emsp;&emsp;`export`&emsp;*ExportClause*&emsp;*FromClause*&emsp;`;`  \r\n&emsp;&emsp;&emsp;`export`&emsp;*ExportClause*&emsp;`;`  \r\n&emsp;&emsp;&emsp;`export`&emsp;*VariableStatement*  \r\n&emsp;&emsp;&emsp;`export`&emsp;*LexicalDeclaration*  \r\n&emsp;&emsp;&emsp;`export`&emsp;*HoistableDeclaration*  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> opt</sub>&emsp;`export`&emsp;[lookahead ≠ @]&emsp;*ClassDeclaration*  \r\n&emsp;&emsp;&emsp;`export`&emsp;`default`&emsp;*HoistableDeclaration*<sub> [Default]</sub>  \r\n&emsp;&emsp;&emsp;*DecoratorList*<sub> opt</sub>&emsp;`export`&emsp;`default`&emsp;[lookahead ≠ @]&emsp;*ClassDeclaration*<sub> [Default]</sub>  \r\n&emsp;&emsp;&emsp;`export`&emsp;`default`&emsp;[lookahead  { function, class, @ }]&emsp;*AssignmentExpression*<sub> [In]</sub>&emsp;`;`\r\n\r\n# <a name=\"B\"/>B Decorator definitions (TypeScript)\r\n\r\n```TypeScript\r\ninterface TypedPropertyDescriptor<T> {  \r\n    enumerable?: boolean;  \r\n    configurable?: boolean;  \r\n    writable?: boolean;  \r\n    value?: T;  \r\n    get?: () => T;  \r\n    set?: (value: T) => void;  \r\n}  \r\n  \r\ninterface ClassDecorator<TFunction extends Function> {  \r\n    (target: TFunction): TFunction | void;  \r\n}  \r\n  \r\ninterface ParameterDecorator {  \r\n    (target: Function, parameterIndex: number): void;  \r\n}  \r\n  \r\ninterface PropertyDecorator<T> {  \r\n    (target: Object, propertyKey: PropertyKey, descriptor: TypedPropertyDescriptor<T>): TypedPropertyDescriptor<T> | void;  \r\n}  \r\n```\r\n\r\n# <a name=\"C\"/>C TypeScript decorators\r\n\r\n## <a name=\"C.1\"/>C.1 Exposing types\r\n\r\nTypeScript compiler can add additional type information then a declaration includes decorators. The types provided are in a serialized form. Serialization logic is descriped in C.2. Reading this type information requires the use of a reflection API (or polyfill for ES6).\r\n\r\n```TypeScript\r\n@dec\r\nclass C {  \r\n    constructor(a: Object, b: number, c: { a: number }, d: C2) {  \r\n    }\r\n\r\n    @dec\r\n    property: string;    \r\n\r\n    @dec\r\n    method(): boolean {\r\n    \treturn true;\r\n    }\r\n}  \r\n  \r\nfunction dec(target: Object, keyOrIndex?: string | symbol | number): void {\r\n\tvar type = Reflect.getMetadata(\"design:type\", target, keyOrIndex);\r\n\tvar paramTypes = Reflect.getMetadata(\"design:paramtypes\", target, keyOrIndex);    \r\n\tvar returnType = Reflect.getMetadata(\"design:returntype\", target, keyOrIndex);\r\n}\r\n\r\n// ES7 emit\r\n@dec\r\n@Reflect.metadata(\"design:type\", Function)\r\n@Reflect.metadata(\"design:paramtypes\", [Object, Number, Object, C2 || Object])\r\nclass C {  \r\n    constructor(a: Object, b: number, c: { a: number }, d: C2) {  \r\n    }  \r\n\r\n    @dec\r\n    @Reflect.metadata(\"design:type\", String)\r\n    property; // assumes property declarations in ES7\r\n\r\n    @dec\r\n    @Reflect.metadata(\"design:type\", Function)\r\n    @Reflect.metadata(\"design:paramtypes\", [])\r\n    @Reflect.metadata(\"design:returntype\", Boolean)\r\n    method() {\r\n    }\r\n}  \r\n\r\n// ES6 emit\r\nvar __decorate = this.__decorate || function (decorators, target, key) {\r\n\tif (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") {\r\n\t\treturn Reflect.decorate(decorators, target, key);\r\n\t}\r\n\t// minimal fallback implementation ...\r\n};\r\nvar __metadata = this.__metadata || function (metadataKey, metadataValue) { \r\n\tif (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") {\r\n\t\treturn Reflect.metadata(metadataKey, metadataValue);\r\n\t}\r\n\treturn function() { \r\n\t\t// default to no metadata\r\n\t}\r\n};\r\n\r\nvar C = (function() {\r\n\tclass C {  \r\n\t    constructor(a, b, c, d) {  \r\n\t    }\r\n\t    method() {\t    \r\n\t\t}\r\n\t}\r\n\t__decorate([dec, __metadata(\"design:type\", String)], C.prototype, \"property\");\r\n\t__decorate([dec, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", Boolean)], C.prototype, \"method\");\r\n\tC = __decorate([dec, __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Number, Object, C2 || Object])], C);\r\n\treturn C;  \r\n})();\r\n```\r\n\r\n## <a name=\"C.2\"/>C.2 Type Serialization:\r\n\r\n### <a name=\"C.2.1\"/>C.2.1 Example\r\n\r\n```TypeScript\r\nclass C { }  \r\ninterface I { }  \r\nenum E { }  \r\nmodule M { }\r\n```\r\n\r\nFormal parameter list in a call signature like so:\r\n\r\n```TypeScript\r\n(a: number, b: boolean, c: C, i: I, e: E, m: typeof M, f: () => void, o: { a: number; b: string; })\r\n```\r\n\r\nSerializes as:\r\n\r\n```TypeScript\r\n[Number, Boolean, C, Object, Number, Object, Function, Object]\r\n```\r\n\r\n### <a name=\"C.2.2\"/>C.2.2 Details\r\n\r\n* number serialized as Number\r\n* string serialized as String\r\n* boolean serialized as Boolean\r\n* any serialized as Object\r\n* void serializes as undefined\r\n* Array serialized as Array\r\n* If a Tuple, serialize as Array\r\n* If a class serialize it as the class constructor\r\n* If an Enum serialize it as Number\r\n* If has at least one call signature, serialize as Function\r\n* Otherwise serialize as Object\r\n\r\n### <a name=\"C.2.3\"/>C.2.3 Helpers for libraries like AngularJS\r\n\r\nSome applications may need a way to easily inject type information in a fashion similar to TypeScript's mechanism, though the applications themselves are written using regular JavaScript. A library could choose to make this process easier for these applications by exposing wrapper metadata functions:\r\n\r\n```TypeScript\r\n// [annotations.ts]\r\nexport function Type(type: Function): Decorator {\r\n\treturn Reflect.metadata(\"design:type\", type);\r\n}\r\n\r\nexport function ParamTypes(...types: Function[]): Decorator {\r\n\treturn Reflect.metadata(\"design:paramtypes\", types);\r\n}\r\n\r\nexport function ReturnType(type: Function): Decorator {\r\n\treturn Reflect.metadata(\"design:returntype\", type);\r\n}\r\n\r\n// app.js\r\ndefine([\"exports\", annotations\"], function (exports, annotations) {\r\n\tvar Component = annotations.Component;\r\n\tvar Type = annotations.Type;\r\n\tvar ParamTypes = annotations.ParamTypes;\r\n\tvar ReturnType = annotations.ReturnType;\r\n\r\n\tfunction MyComponent(a, b) {\r\n\t}\r\n\t\r\n\tMyComponent = Reflect.decorate([Component({ ... }), Type(Function), ParamTypes([UserServiceBase, LocationServiceBase])], MyComponent);\r\n\texports.MyComponent = MyComponent;\r\n})\r\n```\r\n\r\nTypeScript would **not** be providing these helpers, it would be up to library authors to add these if they determine they are necessary. \r\n\r\n### <a name=\"C.2.3\"/>C.2.3 Open issues\r\n\r\n* Do we want to enable more elaborate serialization? \r\n\t* Serialize interfaces or type literals? For example, serialize the type literal `{ a: string; b: number }` as `{ a: String, b: Number }` instead of just `Object`.\r\n\t* Serialize generic type references? One suggestion was to serialize `Array<Number>` as `[Array, Number]`\r\n\t* Serialize tuple types?\r\n\t* Serialize union types?\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}